const path = require('path');
const fs = require('fs');
const git = require('../lib/git.cjs');

// helpers
function shellJoin(cmd, args = []) {
  const q = (s) => `"${String(s).replace(/"/g, '\\"')}"`;
  return [cmd, ...args.map(q)].join(' ');
}
async function runExec(execFn, cmd, args, opts) {
  if (Array.isArray(args)) return execFn(shellJoin(cmd, args), opts);
  return execFn(cmd, args);
}
async function textOut(promise) {
  const r = await promise;
  return String(r && r.stdout ? r.stdout : r).trim();
}
async function hasWorkingChanges(execFn, cwd) {
  try {
    const s = await textOut(
      runExec(execFn, 'git', ['status', '--porcelain'], { cwd }),
    );
    return s.length > 0;
  } catch {
    return true;
  }
}
async function hasStagedChanges(execFn, cwd) {
  const s = await textOut(
    runExec(execFn, 'git', ['diff', '--cached', '--name-only'], { cwd }),
  );
  return s.length > 0;
}
async function ensureLocalIdentity(execFn, cwd) {
  try {
    const name = await textOut(
      runExec(execFn, 'git', ['config', '--get', 'user.name'], { cwd }),
    );
    const email = await textOut(
      runExec(execFn, 'git', ['config', '--get', 'user.email'], { cwd }),
    );
    if (!name)
      await runExec(execFn, 'git', ['config', 'user.name', 'Alice Bot'], {
        cwd,
      });
    if (!email)
      await runExec(
        execFn,
        'git',
        ['config', 'user.email', 'alice@example.local'],
        { cwd },
      );
  } catch {}
}

module.exports = {
  name: 'self-rewrite',
  run: async ({ exec, proposeDiff, datetime }) => {
    const cwd = process.cwd();
    const ALLOW = [
      'server/',
      'client/',
      'autonomy/',
      'package.json',
      'package-lock.json',
    ];

    // Ask for edits (guarded). Safe fallback if not provided.
    if (typeof proposeDiff !== 'function') {
      proposeDiff = async () => ({ ok: true, edits: [] });
    }
    let applied = 0;
    try {
      const plan = await proposeDiff({
        goals: ['improve reliability', 'reduce warnings', 'enhance logs'],
        hard_guards: {
          path_allowlist: ALLOW,
          max_files: 10,
          max_total_change_bytes: 120000,
        },
      });
      for (const e of (plan && plan.edits) || []) {
        const rel = String(e.path || '').replace(/\\/g, '/');
        if (!ALLOW.some((a) => rel === a || rel.startsWith(a))) continue;
        const abs = path.resolve(cwd, e.path);
        const before = fs.existsSync(abs) ? fs.readFileSync(abs, 'utf8') : '';
        const after = typeof e.apply === 'function' ? e.apply(before) : before;
        fs.mkdirSync(path.dirname(abs), { recursive: true });
        fs.writeFileSync(abs, after, 'utf8');
        applied += 1;
        if (applied >= 10) break;
      }
    } catch {}

    // Best-effort format/lint/build (never fail pipeline)
    try {
      await runExec(exec, 'npx', ['prettier', '--write', '.'], { cwd });
    } catch {
      try {
        const bin = path.resolve(
          cwd,
          'node_modules',
          '.bin',
          process.platform === 'win32' ? 'prettier.cmd' : 'prettier',
        );
        await runExec(exec, bin, ['--write', '.'], { cwd });
      } catch {}
    }
    try {
      await runExec(exec, 'npm', ['run', 'lint', '--', '--max-warnings=0'], {
        cwd,
      });
    } catch {}
    try {
      await runExec(exec, 'npm', ['run', 'build'], {
        cwd: path.resolve(cwd, 'client'),
      });
    } catch {}

    // Skip if nothing actually changed
    if (!(await hasWorkingChanges(exec, cwd))) {
      return {
        ok: true,
        note: 'self-rewrite: no changes; repo clean (skipped branch/commit)',
      };
    }

    // Fresh branch only now
    await git.assertClean();
    const branch =
      'autonomy/rewrite-' + datetime().toISOString().replace(/[:.]/g, '-');
    await git.checkoutNew(branch);

    await runExec(exec, 'git', ['add', '-A'], { cwd });
    if (!(await hasStagedChanges(exec, cwd))) {
      return {
        ok: true,
        note: `self-rewrite: nothing staged after add; skipping commit on ${branch}`,
      };
    }

    await ensureLocalIdentity(exec, cwd);
    const msg = `self-rewrite: ${applied} edits`;
    try {
      await runExec(exec, 'git', ['commit', '-m', msg], { cwd });
      return { ok: true, note: `self-rewrite committed (${msg}) on ${branch}` };
      } catch (e) {
    const head = await textOut(runExec(exec, "git", ["rev-parse", "--abbrev-ref", "HEAD"], { cwd }));
    const stagedText = await textOut(runExec(exec, "git", ["diff", "--cached", "--name-only"], { cwd }));
    const stagedArr  = stagedText.split(/\r?\n/).filter(Boolean);
    const stagedTail = stagedArr.slice(0, 5);                 // array
    const stagedStr  = JSON.stringify(stagedTail);            // safe, never [object Object]
    const errStr     = (e && (e.stderr || e.message)) ? String(e.stderr || e.message) : String(e);

    return {
      ok: true,
      note:
        "self-rewrite: commit skipped (git refused). " +
        "branch=" + String(head) +
        " staged=" + stagedStr +
        " msg=\"" + String(`self-rewrite: ${applied} edits`) + "\" " +
        "err=" + errStr
    };
  }),
      );
      const stagedText = await textOut(
        runExec(exec, 'git', ['diff', '--cached', '--name-only'], { cwd }),
      );
      const stagedArr = stagedText.split(/\r?\n/).filter(Boolean);
      const stagedTailStr = stagedArr.slice(0, 5).join(', ') || 'none';
      // Force plain strings to avoid [object Object]
      const errStr =
        e && (e.stderr || e.message)
          ? String(e.stderr || e.message)
          : String(e);
      return {
        ok: true,
        note:
          'self-rewrite: commit skipped (git refused). branch=' +
          String(head) +
          ' staged=[' +
          String(stagedTailStr) +
          '] msg="' +
          String(msg) +
          '" err=' +
          errStr,
      };
    }
  },
};

console.log('[SELF-REWRITE MARK] loaded:', __filename);

