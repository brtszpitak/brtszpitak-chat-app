const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const axios = require("axios");
const { URL } = require("url");

const cfg = require("../config/download.json");

function sha256OfFile(filePath) {
  const hash = crypto.createHash("sha256");
  const stream = fs.createReadStream(filePath);
  return new Promise((resolve, reject) => {
    stream.on("data", (d) => hash.update(d));
    stream.on("end", () => resolve(hash.digest("hex")));
    stream.on("error", reject);
  });
}

function ensureHttpsAndAllowed(url) {
  const u = new URL(url);
  if (u.protocol !== "https:") throw new Error("Only HTTPS URLs are allowed.");
  const host = u.hostname.toLowerCase();
  if (!cfg.allowedDomains.some((d) => host === d || host.endsWith("." + d))) {
    throw new Error(`Domain not allowed: ${host}`);
  }
  return u;
}

async function downloadToFile({ url, destDir, filename, expectedSha256 }) {
  const u = ensureHttpsAndAllowed(url);
  const safeName = filename || path.basename(u.pathname) || "download.bin";
  const fullPath = path.join(destDir, safeName);

  // HEAD to check size (best effort)
  try {
    const head = await axios.head(u.toString(), { maxRedirects: 5, timeout: 15000 });
    const len = parseInt(head.headers["content-length"] || "0", 10);
    if (len && len > cfg.maxBytes) {
      throw new Error(`File too large: ${len} > ${cfg.maxBytes} bytes`);
    }
  } catch (e) {
    // continue on HEAD failures; enforce during GET stream
  }

  const writer = fs.createWriteStream(fullPath);
  let received = 0;

  const resp = await axios.get(u.toString(), {
    responseType: "stream",
    maxRedirects: 5,
    timeout: 30000,
  });
  return new Promise((resolve, reject) => {
    resp.data.on("data", (chunk) => {
      received += chunk.length;
      if (received > cfg.maxBytes) {
        resp.data.destroy(new Error(`File exceeded size limit ${cfg.maxBytes} bytes`));
      }
    });
    resp.data.pipe(writer);
    writer.on("finish", async () => {
      try {
        const actualSha = await sha256OfFile(fullPath);
        if (expectedSha256 && actualSha.toLowerCase() !== expectedSha256.toLowerCase()) {
          return reject(new Error(`SHA256 mismatch: expected ${expectedSha256}, got ${actualSha}`));
        }
        resolve({ path: fullPath, bytes: received, sha256: actualSha });
      } catch (err) {
        reject(err);
      }
    });
    writer.on("error", reject);
  });
}

module.exports = { downloadToFile, ensureHttpsAndAllowed, sha256OfFile };
